violates 违反 modularity 模块化  scenario 场景 parameterize 参数化 retain 保留 capture 捕获 deprecated 弃用
visualize 可视化  scrollable 可滚动的  geometrical 几何  alternatively 另外 validate nested 嵌套的 symmetry 对称
viewport 视窗 render 渲染   ownership 所有权   affine 仿射的  matrix 矩阵 intersect 相交 resemble 类似，像
scale 规模    shear 剪切    typically 通常    toggle 切换   anchor 抛锚;锚 mandatory 强制的；托管的；命令的
partial 部分  texture 纹理  gradient 梯度 alpha 开端；最初 degrade 降低  retrieve 检索 contiguously 连续
iterate 迭代  predictable 可预测的    extract 提取  qualify 限定，修饰；使具有资格；证明…合格 canonical 规范
sufficient 足够的，充分的  straightforward 简单的；坦率的；明确的；径直的 adequate 充足的 redundant 冗余
synonym 同义词 irrespective 不考虑的   terminology 术语  notation 符号 proportional 成比例的 colon 冒号
logarithm 对数    asymptotically 渐近   sole 唯一 adjacent 相邻 versatile通用的 inverse 相反的
conjunction 结合 interpreted 解释 seamless 无缝的 hierarchy 等级,层级制度 dangling 悬挂的，摇摆的
paradigm 范式 omit 省略 postpone 推迟 disambiguation 消除模棱两可情况，解疑  incompatible  不兼容的
T qobject_cast(QObject* object)
返回object向下的转型T，转型成功返回0，如果传入的object本省就是0则返回0
使用时的两个限制：
1. T类型必须继承自QObject。
2. 在声明时必须有Q_OBJECT宏
Q_DECLARE_METATYPE   Q_DECLARE_OPAQUE_POINTER qRegisterMetaType()
通过QWidget * QApplication::focusWidget()可以获得当前拥有焦点的widget

static_cast相当于传统的C语言里的强制转换，该运算符把expression转换为new_type类型，用来强迫隐式转换如non-const对象转为const对象，编译时检查，用于非多态的转换，可以转换指针及其他，但没有运行时类型检查来保证转换的安全性。它主要有如下几种用法：

①用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。
进行上行转换（把派生类的指针或引用转换成基类表示）是安全的；
进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
②用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。
③把空指针转换成目标类型的空指针。
④把任何类型的表达式转换成void类型。
注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性

dynamic_cast< type* >(e)
　type必须是一个类类型且必须是一个有效的指针
dynamic_cast< type& >(e)
type必须是一个类类型且必须是一个左值
dynamic_cast< type&& >(e)
type必须是一个类类型且必须是一个右值

e的类型必须符合以下三个条件中的任何一个：
1、e的类型是目标类型type的公有派生类
2、e的类型是目标type的共有基类
3、e的类型就是目标type的类型。

如果一条dynamic_cast语句的转换目标是指针类型并且失败了，则结果为0。
如果转换目标是引用类型并且失败了，则dynamic_cast运算符将抛出一个std::bad_cast异常
(该异常定义在typeinfo标准库头文件中)。e也可以是一个空指针，结果是所需类型的空指针。

dynamic_cast主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换（cross cast）。

在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；
在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。
dynamic_cast是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作

QSet operator&() oparator-()
     operator+() operator|()

******************2020.12.10 QObject对象**********************
disconnect(myObject, 0, 0, 0);
myObject->disconnect();
disconnect(myobject, SIGNAL(mySignal()), 0 ,0);
myObject->disconnect(SIGNAL(mySignal()));
disconnect(myObject, 0, myReceiver, 0);
myObject->disconnect(myReceiver);
可以在发射信号前，判断信号是否已经有接收者 isSignalConnected(const QMetaMethod &signal)
QContainer可以被QDataStream读取和写入的基础是，其包含的Type必须提供operator<<(QDaraStream &out, const Type& type)和operator>>(QDataStream &in, Type type)
使用foreach遍历容器时，会发生拷贝操作，如果在循环中修改数据，不会影响到原容器中的数据
Other QContainerS: QVarLengthArray,QCache,QPair,QContigousCache













































QListIteraotr QMutableListIterator
QMapIterator QMutableMapIterator
QHashIterator QMutableMapIterator
QLinkedListIterator QMutableLinkedListIterator
QVectorIterator QMutableVectorIterator
Q_CLASSINFO
QT_SHAREDPOINTER_TRACK_POINTERS
QSharedData
QSharedDataPointer
QSharedExplicitlyDataPointer
